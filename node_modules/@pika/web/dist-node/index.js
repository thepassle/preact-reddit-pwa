'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var fs = _interopDefault(require('fs'));
var path = _interopDefault(require('path'));
var rimraf = _interopDefault(require('rimraf'));
var mkdirp = _interopDefault(require('mkdirp'));
var chalk = _interopDefault(require('chalk'));
var glob = _interopDefault(require('glob'));
var ora = _interopDefault(require('ora'));
var yargs = _interopDefault(require('yargs-parser'));
var resolveFrom = _interopDefault(require('resolve-from'));
var rollup = require('rollup');
var rollupPluginNodeResolve = _interopDefault(require('rollup-plugin-node-resolve'));
var rollupPluginCommonjs = _interopDefault(require('rollup-plugin-commonjs'));
var rollupPluginTerser = require('rollup-plugin-terser');
var rollupPluginReplace = _interopDefault(require('rollup-plugin-replace'));
var rollupPluginJson = _interopDefault(require('rollup-plugin-json'));
var rollupPluginBabel = _interopDefault(require('rollup-plugin-babel'));
var babelPresetEnv = _interopDefault(require('@babel/preset-env'));
var isNodeBuiltin = _interopDefault(require('is-builtin-module'));

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function fromEntries(iterable) {
  return [...iterable].reduce((obj, {
    0: key,
    1: val
  }) => Object.assign(obj, {
    [key]: val
  }), {});
}

const cwd = process.cwd();
const banner = chalk.bold(`@pika/web`) + ` installing... `;
const detectionResults = [];
let spinner = ora(banner);
let spinnerHasError = false;

function printHelp() {
  console.log(`
${chalk.bold(`@pika/web`)} - Install npm dependencies to run natively on the web.
${chalk.bold('Options:')}
    --dest              Specify destination directory (default: "web_modules/").
    --clean             Clear out the destination directory before install.
    --optimize          Transpile, minify, and optimize installed dependencies for production.
    --babel             Transpile installed dependencies. Also enabled with "--optimize".
    --strict            Only install pure ESM dependency trees. Fail if a CJS module is encountered.
    --no-source-map     Skip emitting source map files (.js.map) into dest
${chalk.bold('Advanced:')}
    --remote-package    "name,version" pair(s) of packages that should be left unbundled and referenced remotely.
                        Example: "foo,v4" will rewrite all imports of "foo" to "{remoteUrl}/foo/v4" (see --remote-url).
    --remote-url        Configures the domain where remote imports point to (default: "https://cdn.pika.dev")
    `.trim());
}

function formatDetectionResults(skipFailures) {
  return detectionResults.map(([d, yn]) => yn ? chalk.green(d) : skipFailures ? chalk.dim(d) : chalk.red(d)).join(', ');
}

function logError(msg) {
  if (!spinnerHasError) {
    spinner.stopAndPersist({
      symbol: chalk.cyan('â ¼')
    });
  }

  spinnerHasError = true;
  spinner = ora(chalk.red(msg));
  spinner.fail();
}

class ErrorWithHint extends Error {
  constructor(message, hint) {
    super(message);
    this.hint = hint;
  }

} // Add common, well-used non-esm packages here so that Rollup doesn't die trying to analyze them.


const PACKAGES_TO_AUTO_DETECT_EXPORTS = [path.join('react', 'index.js'), path.join('react-dom', 'index.js'), path.join('react-is', 'index.js'), path.join('prop-types', 'index.js'), path.join('rxjs', 'Rx.js')];

function detectExports(filePath) {
  try {
    const fileLoc = resolveFrom(cwd, filePath);

    if (fs.existsSync(fileLoc)) {
      return Object.keys(require(fileLoc)).filter(e => e[0] !== '_');
    }
  } catch (err) {// ignore
  }
}
/**
 * Resolve a "webDependencies" input value to the correct absolute file location.
 * Supports both npm package names, and file paths relative to the node_modules directory.
 * Follows logic similar to Node's resolution logic, but using a package.json's ESM "module"
 * field instead of the CJS "main" field.
 */


function resolveWebDependency(dep, isExplicit) {
  // if the path includes a file extension, just use it
  if (path.extname(dep)) {
    const isJSFile = ['.js', '.mjs', '.cjs'].includes(path.extname(dep));
    return {
      type: isJSFile ? 'JS' : 'ASSET',
      loc: resolveFrom(cwd, dep)
    };
  }

  const depManifestLoc = resolveFrom(cwd, `${dep}/package.json`);

  const depManifest = require(depManifestLoc);

  let foundEntrypoint = depManifest.module; // If the package was a part of the explicit whitelist, fallback to it's main CJS entrypoint.

  if (!foundEntrypoint && isExplicit) {
    foundEntrypoint = depManifest.main || 'index.js';
  }

  if (!foundEntrypoint) {
    throw new ErrorWithHint(`dependency "${dep}" has no native "module" entrypoint.`, chalk.italic(`Tip: Find modern, web-ready packages at ${chalk.underline('https://www.pika.dev')}`));
  }

  if (dep === 'react' && foundEntrypoint === 'index.js') {
    throw new ErrorWithHint(`dependency "react" has no native "module" entrypoint.`, chalk.italic(`See: ${chalk.underline('https://github.com/pikapkg/web#a-note-on-react')}`));
  }

  return {
    type: 'JS',
    loc: path.join(depManifestLoc, '..', foundEntrypoint)
  };
}
/**
 * Formats the @pika/web dependency name from a "webDependencies" input value:
 * 2. Remove any ".js" extension (will be added automatically by Rollup)
 */


function getWebDependencyName(dep) {
  return dep.replace(/\.js$/, '');
}

async function install(arrayOfDeps, {
  isCleanInstall,
  destLoc,
  hasBrowserlistConfig,
  isExplicit,
  isStrict,
  isBabel,
  isOptimized,
  sourceMap,
  namedExports,
  remoteUrl,
  remotePackages
}) {
  const nodeModulesLoc = path.join(cwd, 'node_modules');

  const knownNamedExports = _objectSpread2({}, namedExports);

  const remotePackageMap = fromEntries(remotePackages);
  const depList = new Set();
  arrayOfDeps.forEach(dep => {
    if (!glob.hasMagic(dep)) {
      depList.add(dep);
    } else {
      glob.sync(dep, {
        cwd: nodeModulesLoc,
        nodir: true
      }).forEach(f => depList.add(f));
    }
  });

  for (const filePath of PACKAGES_TO_AUTO_DETECT_EXPORTS) {
    knownNamedExports[filePath] = knownNamedExports[filePath] || detectExports(filePath) || [];
  }

  if (depList.size === 0) {
    logError('no dependencies found.');
    return;
  }

  if (!fs.existsSync(path.join(cwd, 'node_modules'))) {
    logError('no "node_modules" directory exists. Did you run "npm install" first?');
    return;
  }

  if (isCleanInstall) {
    rimraf.sync(destLoc);
  }

  const depObject = {};
  const assetObject = {};
  const importMap = {};
  const skipFailures = !isExplicit;

  for (const dep of depList) {
    try {
      const depName = getWebDependencyName(dep);
      const {
        type: depType,
        loc: depLoc
      } = resolveWebDependency(dep, isExplicit);

      if (depType === 'JS') {
        depObject[depName] = depLoc;
        importMap[depName] = `./${depName}.js`;
        detectionResults.push([dep, true]);
      }

      if (depType === 'ASSET') {
        assetObject[depName] = depLoc;
        detectionResults.push([dep, true]);
      }

      spinner.text = banner + formatDetectionResults(skipFailures);
    } catch (err) {
      detectionResults.push([dep, false]);
      spinner.text = banner + formatDetectionResults(skipFailures);

      if (skipFailures) {
        continue;
      } // An error occurred! Log it.


      logError(err.message || err);

      if (err.hint) {
        console.log(err.hint);
      }

      return false;
    }
  }

  if (Object.keys(depObject).length === 0 && Object.keys(assetObject).length === 0) {
    logError(`No ESM dependencies found!`);
    console.log(chalk.dim(`  At least one dependency must have an ESM "module" entrypoint. You can find modern, web-ready packages at ${chalk.underline('https://www.pika.dev')}`));
    return false;
  }

  if (Object.keys(depObject).length > 0) {
    const inputOptions = {
      input: depObject,
      plugins: [!isStrict && rollupPluginReplace({
        'process.env.NODE_ENV': isOptimized ? '"production"' : '"development"'
      }), remotePackages.length > 0 && {
        name: 'pika:peer-dependency-resolver',

        resolveId(source) {
          if (remotePackageMap[source]) {
            let urlSourcePath = source; // NOTE(@fks): This is really Pika CDN specific, but no one else should be using this option.

            if (source === 'react' || source === 'react-dom') {
              urlSourcePath = '_/' + source;
            }

            return {
              id: `${remoteUrl}/${urlSourcePath}/${remotePackageMap[source]}`,
              external: true,
              isExternal: true
            };
          }

          return null;
        },

        load(id) {
          return null;
        }

      }, rollupPluginNodeResolve({
        mainFields: ['browser', 'module', !isStrict && 'main'].filter(Boolean),
        modulesOnly: isStrict,
        extensions: ['.mjs', '.cjs', '.js', '.json'],
        // whether to prefer built-in modules (e.g. `fs`, `path`) or local ones with the same names
        preferBuiltins: false
      }), !isStrict && rollupPluginJson({
        preferConst: true,
        indent: '  '
      }), !isStrict && rollupPluginCommonjs({
        extensions: ['.js', '.cjs'],
        namedExports: knownNamedExports
      }), !!isBabel && rollupPluginBabel({
        compact: false,
        babelrc: false,
        presets: [[babelPresetEnv, {
          modules: false,
          targets: hasBrowserlistConfig ? undefined : '>0.75%, not ie 11, not op_mini all'
        }]]
      }), !!isOptimized && rollupPluginTerser.terser()],
      onwarn: (warning, warn) => {
        if (warning.code === 'UNRESOLVED_IMPORT') {
          logError(`'${warning.source}' is imported by '${warning.importer}', but could not be resolved.`);

          if (isNodeBuiltin(warning.source)) {
            console.log(chalk.dim(`  '${warning.source}' is a Node.js builtin module that won't exist on the web. You can find modern, web-ready packages at ${chalk.underline('https://www.pika.dev')}`));
          } else {
            console.log(chalk.dim(`  Make sure that the package is installed and that the file exists.`));
          }

          return;
        }

        warn(warning);
      }
    };
    const outputOptions = {
      dir: destLoc,
      format: 'esm',
      sourcemap: sourceMap === undefined ? isOptimized : sourceMap,
      exports: 'named',
      chunkFileNames: 'common/[name]-[hash].js'
    };
    const packageBundle = await rollup.rollup(inputOptions);
    await packageBundle.write(outputOptions);
    fs.writeFileSync(path.join(destLoc, 'import-map.json'), JSON.stringify({
      imports: importMap
    }, undefined, 2), {
      encoding: 'utf8'
    });
  }

  Object.entries(assetObject).forEach(([assetName, assetLoc]) => {
    mkdirp.sync(path.dirname(`${destLoc}/${assetName}`));
    fs.copyFileSync(assetLoc, `${destLoc}/${assetName}`);
  });
  return true;
}
async function cli(args) {
  const {
    help,
    sourceMap,
    babel = false,
    optimize = false,
    strict = false,
    clean = false,
    dest = 'web_modules',
    remoteUrl = 'https://cdn.pika.dev',
    remotePackage: remotePackages = []
  } = yargs(args);
  const destLoc = path.resolve(cwd, dest);

  if (help) {
    printHelp();
    process.exit(0);
  }

  const pkgManifest = require(path.join(cwd, 'package.json'));

  const {
    namedExports,
    webDependencies
  } = pkgManifest['@pika/web'] || {
    namedExports: undefined,
    webDependencies: undefined
  };
  const doesWhitelistExist = !!webDependencies;
  const arrayOfDeps = webDependencies || Object.keys(pkgManifest.dependencies || {});
  const hasBrowserlistConfig = !!pkgManifest.browserslist || !!process.env.BROWSERSLIST || fs.existsSync(path.join(cwd, '.browserslistrc')) || fs.existsSync(path.join(cwd, 'browserslist'));
  spinner.start();
  const startTime = Date.now();
  const result = await install(arrayOfDeps, {
    isCleanInstall: clean,
    destLoc,
    namedExports,
    isExplicit: doesWhitelistExist,
    isStrict: strict,
    isBabel: babel || optimize,
    isOptimized: optimize,
    sourceMap,
    remoteUrl,
    hasBrowserlistConfig,
    remotePackages: remotePackages.map(p => p.split(','))
  });

  if (result) {
    spinner.succeed(chalk.bold(`@pika/web`) + ` installed: ` + formatDetectionResults(!doesWhitelistExist) + '. ' + chalk.dim(`[${((Date.now() - startTime) / 1000).toFixed(2)}s]`));
  }

  if (spinnerHasError) {
    // Set the exit code so that programmatic usage of the CLI knows that there were errors.
    spinner.warn(chalk(`Finished with warnings.`));
    process.exitCode = 1;
  }
}

exports.cli = cli;
exports.install = install;
//# sourceMappingURL=index.js.map
