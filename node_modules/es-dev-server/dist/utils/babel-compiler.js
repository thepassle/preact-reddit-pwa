"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createBabelCompiler;

var _core = require("@babel/core");

var _deepmerge = _interopRequireDefault(require("deepmerge"));

var _buildingUtils = require("@open-wc/building-utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// string length at which babel starts deoptimizing
const BABEL_DEOPTIMIZED_LENGTH = 500000;
/**
 * @typedef {object} CreateBabelCompilerConfig
 * @property {boolean} readUserBabelConfig
 * @property {boolean} modern
 * @property {object} [customBabelConfig]
 * @property {boolean} legacy
 * @property {boolean} [systemJs]
 */

/** @param {boolean} readUserBabelConfig */

function createDefaultConfig(readUserBabelConfig) {
  return {
    caller: {
      name: 'es-dev-server',
      supportsStaticESM: true
    },
    plugins: [require.resolve('@babel/plugin-syntax-dynamic-import'), require.resolve('@babel/plugin-syntax-import-meta')],
    sourceType: 'module',
    // only read the user's babelrc and config if explicitly enabled
    babelrc: readUserBabelConfig,
    configFile: readUserBabelConfig
  };
}

const modernConfig = {
  presets: [['@babel/preset-env', {
    targets: (0, _buildingUtils.findSupportedBrowsers)(),
    useBuiltIns: false,
    modules: false
  }]]
};
const legacyConfig = {
  presets: [['@babel/preset-env', {
    targets: ['ie 11'],
    useBuiltIns: false,
    modules: 'systemjs'
  }]]
};
/**
 * Creates a babel compiler backed by an in-memory last-read-out cache. Sets up configuration
 * based on a number of presets.
 *
 * @param {CreateBabelCompilerConfig} cfg
 */

function createBabelCompiler(cfg) {
  // create babel configuration based on a number of presets
  const babelConfigs = [// custom babel config if it's there
  createDefaultConfig(cfg.readUserBabelConfig), cfg.modern && modernConfig, cfg.legacy && legacyConfig, cfg.customBabelConfig].filter(Boolean);

  const babelConfig = _deepmerge.default.all(babelConfigs);
  /**
   * @param {string} filename
   * @param {string} source
   * @returns {Promise<string>}
   */


  function compile(filename, source) {
    // babel runs out of memory when processing source maps for large files
    const sourceMaps = source.length > BABEL_DEOPTIMIZED_LENGTH ? false : 'inline';
    return (0, _core.transformAsync)(source, {
      filename,
      sourceMaps,
      ...babelConfig
    }).then(result => result.code);
  }

  return compile;
}